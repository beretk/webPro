-- [VII] DDL, DML, DCL
-- SQL = DDL(테이블 생성, 테이블 삭제, 테이블 구조 변경, 테이블의 모든 데이터제거) + 
--       DML(SELECT, INSERT, UPDATE, DELETE) + 
--       DCL(사용자계정 생성, 사용자에게 권한부여, 권한박탈, 사용자계정 삭제, 트랜젝션명령어)

-- ★★★DDL★★★
-- 1. 테이블 생성(CREATE TABLE 테이블명 ....) : 테이블 구조를 정의
CREATE TABLE BOOK (
    BOOKID    NUMBER(4), -- BOOKID 필드의 타입은 숫자4자리
    BOOKNAME  VARCHAR2(20), -- BOOKNAME 필드의 타입은 문자 20BYTE ; 최대 4000BYTE 까지 가능
    PUBLISHER VARCHAR2(20), -- PUBLISHER 필드의 타입은 문자 20BYTE
    RDATE     DATE,         -- RDATE 필드의 타입은 DATE
    PRICE     NUMBER(7,2),  -- PRICE 필드의 타입은 숫자 전체 7자리. 소수점이하는 2자리, 소수점앞 5자리
    PRIMARY KEY(BOOKID)     -- 제약조건 : BOOKID필드가 PRIMARY KEY(주키) : UNIQUE, NOT NULL
);
SELECT * FROM BOOK;
DESC BOOK;

DROP TABLE BOOK; -- 테이블 삭제
CREATE TABLE BOOK(
    BOOKID    NUMBER(4) PRIMARY KEY,
    BOOKNAME  VARCHAR2(20), 
    PUBLISHER VARCHAR2(20),  
    RDATE     DATE,         
    PRICE     NUMBER(7,2)
);
 -- DEPT01 : DEPTNO(수2:PK),
CREATE TABLE DEPT01 (
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME  VARCHAR2(14),
    LOC    VARCHAR2(13)
);
    SELECT * FROM DEPT01;
    -- EMP01 : EMPNO(수4:PK주키), ENAME(문자10), SAL(수7,2), DEPTNO(수2:FK외래키)
    CREATE TABLE EMP01(
     EMPNO NUMBER(4) PRIMARY KEY,
     ENAME VARCHAR2(10),
     SAL   NUMBER(7,2),
    DEPTNO NUMBER(2)  REFERENCES DEPT01(DEPTNO)
);
    SELECT * FROM EMP01;

    -- 서브쿼리를 이용한 테이블 생성(BACKUP용도로 사용)
        -- EMP02 == EMP
    CREATE TABLE EMP02
        AS
        SELECT * FROM EMP; -- 서브쿼리 결과로 EMP02테이블 생성후 데이터로 들어감(제약조건 미포함)
    SELECT * FROM EMP02;
        -- EMP03 == EMP의 특정 필드
    CREATE TABLE EMP03
        AS
        SELECT EMPNO, ENAME, DEPTNO FROM EMP; -- EMP 테이블의 EMPNO, ENAME, DEPTNO만 추출한 데이터가 EMP03
    SELECT * FROM EMP03;
        -- EMP04 == EMP의 특정행
    CREATE TABLE EMP04
        AS
        SELECT * FROM EMP WHERE DEPTNO=10; -- EMP에서 10번 부서의 데이터만 추출해서 EMP04
    SELECT * FROM EMP04;
        -- EMP05 == EMP의 구조만 추출(데이터 추출하지 않음)
    CREATE TABLE EMP05
        AS
        SELECT * FROM EMP WHERE 1=0;
    SELECT * FROM EMP05;
    SELECT ROWNUM, EMPNO, ENAME FROM EMP; -- ROWNUM : 테이블에서 행의 읽어들인 순서

-- 2. 테이블 구조변경 ( ALTER TABLE 테이블이름 ADD || MODIFY || DROP ~)
-- (1)필드추가(ADD)
SELECT * FROM EMP03; -- EMPNO숫자4, ENAME(문자10), DEPTNO(숫자2)
ALTER TABLE EMP03 ADD (JOB VARCHAR2(20), SAL NUMBER(7));
SELECT * FROM EMP03; -- 추가된 필드는 NULL 데이터로 채워짐
-- (2) 필드수정 (MODIFY)
ALTER TABLE EMP03 MODIFY(EMPNO VARCHAR2(4)); -- 숫자 데이터가 들어있는 숫자로만 변경 가능(숫자보다 큰 사이즈로만)
ALTER TABLE EMP03 MODIFY(EMPNO NUMBER(5));
ALTER TABLE EMP03 MODIFY(JOB NUMBER(5)); -- NULL 필드는 마음대로 수정 가능
SELECT MAX(LENGTH(ENAME)) FROM EMP03; -- EMP03의 ENAME은 6글자가 최장길이
ALTER TABLE EMP03 MODIFY(ENAME VARCHAR2(6)); -- 문자데이터를 늘리거나 줄이는데는 기존 데이터에 따라 가능
-- (3) 필드 삭제 (DROP)
ALTER TABLE EMP03 DROP COLUMN JOB; -- JOB 필드 삭제
SELECT * FROM EMP03;
ALTER TABLE EMP03 DROP COLUMN DEPTNO;

-- 3. 테이블 삭제 (DROP TABLE 테이블명)
DROP TABLE EMP01;
SELECT * FROM EMP01;
DROP TABLE DEPT; -- EMP테이블에서 DEPT의 DEPTNO를 참조하는 경우 EMP테이블을 삭제한 후 DEPT를 삭제

-- 4. 테이블의 모든 행을 제거(TRUNCATE TABLE 테이블명)
SELECT * FROM EMP03;
TRUNCATE TABLE EMP03; -- ROLLBACK 불가
SELECT * FROM EMP03;

-- 5. 테이블명변경 (RENAME 테이블명 TO 바꿀테이블명)
SELECT * FROM EMP02;
RENAME EMP02 TO EMP2;
SELECT * FROM EMP2;

-- 6. 데이터 딕셔너리(데이터베이스 자원을 효율적으로 관리하기 위한 시스템 테이블 : 접근불가)
--        VS
-- 데이터 딕셔너리 뷰(접근가능)의 종류
-- (1) USER_XXX : 현 계정에서 소유하고 있는 객체(테이블, 제약조건, 뷰, 인덱스)
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS;
SELECT * FROM USER_VIEWS;
SELECT * FROM USER_INDEXES;
-- (2) ALL_XXX : 현 계정에서 접근가능한 객체(테이블, 제약조건, 뷰, 인덱스)
SELECT * FROM ALL_TABLES;
SELECT * FROM ALL_CONSTRAINTS;
SELECT * FROM ALL_VIEWS;
SELECT * FROM ALL_INDEXES;
-- (3) DBA_XXX : DBA권한에서만 접근 가능 DBMS의 모든 객체(테이블, 제약조건, 뷰, 인덱스)
SELECT * FROM DBA_TABLES;
SELECT * FROM DBA_CONSTRAINTS;
SELECT * FROM DBA_VIEWS;
SELECT * FROM DBA_INDEXES;

-- ★★★DML★★★
-- 1. INSERT INTO 테이블명 VALUES (값1, 값2, ...);
-- INSERT INTO 테이블명(필드1, 필드2, ..) VALUES (값1, 값2,...);
SELECT * FROM DEPT01;
INSERT INTO DEPT01 VALUES(50, 'ACCOUNTING', 'SEOUL');
INSERT INTO DEPT01 VALUES(60, 'SALES', NULL); -- 명시적으로 NULL 추가
INSERT INTO DEPT01 (DEPTNO, LOC, DNAME) VALUES(70, '서대문' ,'RESEARCH'); 
INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES (80, 'IT'); -- 묵시적으로 NULL추가(명시되지 않은 필드값은 NULL)
SELECT * FROM DEPT01;
COMMIT; -- 트랜젝션 명령어(DML명령어만 적용) : 데이터 처리를 위한 한 단위
        -- 트랜젝션에 있는 명령어들을 오라클에 반영
-- 서브쿼리를 이용한 INSERT
    -- DEPT테이블의  10~30부서를 DEPT01FH INSERT
INSERT INTO DEPT01 SELECT * FROM DEPT WHERE DEPTNO BETWEEN 10 AND 30;
SELECT * FROM DEPT01;
COMMIT;
ROLLBACT; -- 현 트랙젝션 작업을 취소

-- ※연습문제 (pdf 1페이지)
DROP TABLE SAM01;
CREATE TABLE SAM01(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10),
    JOB   VARCHAR2(9),
    SAL   NUMBER(7,2)
);
SELECT * FROM SAM01;
INSERT INTO SAM01 VALUES(1000, 'APPLE', 'POLICE', 10000);
INSERT INTO SAM01 VALUES(1010, 'BANANA', 'NURSE', 15000);
INSERT INTO SAM01 VALUES(1020, 'ORANGE', 'DOCTOR', 25000);
INSERT INTO SAM01 VALUES(1030, 'VERY', NULL, 25000);
INSERT INTO SAM01 VALUES(1040, 'CAT', NULL, 2000);
INSERT INTO SAM01
    SELECT EMPNO, ENAME, JOB, SAL FROM EMP WHERE DEPTNO=10;
SELECT * FROM SAM01;
COMMIT;

-- 2. UPDATE 테이블 SET 필드명1=값1, 필드명2=값2,... [WHERE 조건];
SELECT * FROM EMP01;
DROP TABLE EMP01;
CREATE TABLE EMP01 AS SELECT EMPNO, ENAME, SAL, HIREDATE, DEPTNO FROM EMP;
    -- 부서번호를 30으로 수정
    COMMIT;
    UPDATE EMP01 SET DEPTNO=30;
    SELECT * FROM EMP01;
    ROLLBACK;
    -- ex. 모든 직원(EMP01)의 급여(SAL) 를 10%인산
    UPDATE EMP01 SET SAL = SAL*1.1;
    SELECT * FROM EMP01;
    -- ex. EMP01 : 10번부서 직원의 입사일을 오늘, 부서번호는 30번으로 수정
    UPDATE EMP01 
        SET HIREDATE = SYSDATE, 
        DEPTNO = 30 
    WHERE DEPTNO=10;
    SELECT * FROM EMP01;
    -- ex. 급여가 3000이상인 사원만 급여를 10%인상
    UPDATE EMP01 
        SET SAL = SAL*1.1 WHERE SAL>=3000;
    SELECT * FROM EMP01;    
    -- ex. EMP01테이블에서 ‘DALLAS’에서 근무하는 직원들의 급여를 1000$인상
    UPDATE EMP01
        SET SAL = SAL+1000
        WHERE DEPTNO = (SELECT DEPTNO FROM DEPT WHERE LOC='DALLAS');
    ROLLBACK;
    -- ex. SCOTT사원의 부서번호는 20번으로, 직급은 MANAGER로 한꺼번에 수정
    SELECT * FROM EMP;
    SELECT * FROM EMP WHERE ENAME='SCOTT';
    UPDATE EMP 
        SET DEPTNO=20, JOB='MANAGER' WHERE ENAME='SCOTT';
    ROLLBACK;
    -- ex. 급여가 1500이하인 직원의 급여를 1500으로 수정
    SELECT * FROM EMP01;
    UPDATE EMP01
        SET SAL = 1500 WHERE SAL <= 1500;
    -- ex. 모든 사원의 급여와 입사일을 'KING'의 급여와 입사일로 수정
    UPDATE EMP01
        SET SAL = (SELECT SAL FROM EMP01 WHERE ENAME='KING'),
        HIREDATE = (SELECT HIREDATE FROM EMP01 WHERE ENAME='KING');
    UPDATE EMP01
        SET(SAL, HIREDATE) = (SELECT SAL, HIREDATE FROM EMP01 WHERE ENAME='KING');

-- 3.DELETE FROM 테이블명 [WHERE 조건];
SELECT * FROM EMP01;
DELETE FROM EMP01;
ROLLBACK;
    -- EMP01 : 30번부서 직원만 삭제
    DELETE FROM EMP01 WHERE DEPTNO=30;
    SELECT * FROM EMP01;
    ROLLBACK;
    -- EMP01 : 부서명이 SALES 부서의 직원만 삭제
    DELETE FROM EMP01 WHERE DEPTNO IN (SELECT DEPTNO FROM DEPT01 WHERE DNAME='SALES');
    SELECT * FROM EMP01;
    -- EMP01 : FORD사원을 삭제
    DELETE FROM EMP01 WHERE ENAME='FORD';
    -- SAM01 : JOB인 NULL인 사원을 삭제
    SELECT * FROM SAM01 WHERE JOB IS NULL;
    DELETE FROM SAM01 WHERE JOB IS NULL;
    -- SAM01 :  ENAME이 ORANGE인 사원을 삭제
    SELECT * FROM SAM01;
    DELETE FROM SAM01 WHERE ENAME = 'ORANGE';
    -- EMP01 : 급여가 1500이하인 직원의 급여를 1500으로
    SELECT * FROM EMP01;
    UPDATE EMP01 SET SAL=1500 WHERE SAL <= 1500;

-- ※ 연습문제 (CREAT TABLE, DROP TABLE, INSERT, UPDATE, DELETE, COMMIT)
-- 1. 아래의 구조를 만족하는 MY_DATA 테이블을 생성하시오. 단 ID가 PRIMARY KEY이다.
DROP TABLE MY_DATA;
CREATE TABLE MY_DATA(
    ID  number(4) PRIMARY KEY,
    NAME  varchar2(10),
    USERID  varchar2(30),
    SALARY  number(10,2)
);
SELECT * FROM MY_DATA;
-- 2. 생성된 테이블에 위의 도표와 같은 값을 입력하는 SQL문을 작성하시오.
INSERT INTO MY_DATA VALUES(1, 'Scott', 'sscott', 10000.00);
INSERT INTO MY_DATA VALUES(2, 'Ford', 'fford', 13000.00);
INSERT INTO MY_DATA VALUES(3, 'Patel', 'ppatel', 33000.00);
INSERT INTO MY_DATA VALUES(4, 'Report', 'rreport', 23500.00);
INSERT INTO MY_DATA VALUES(5, 'Good', 'ggood', 44450.00);
SELECT * FROM MY_DATA;

-- 3. TO_CHAR 내장 함수를 이용하여 입력한 자료를 위의 도표와 같은 형식으로 출력하는 SQL문을 작성하시오.
SELECT ID, NAME, USERID, SALARY, TO_CHAR(SALARY, '99,999.99') FROM MY_DATA;

-- 4. 자료를 영구적으로 데이터베이스에 등록하는 명령어를 작성하시오.
COMMIT;

-- 5. ID가 3번인 사람의 급여를 65000.00으로 갱신하고 영구적으로 데이터베이스에 반영하라.
UPDATE MY_DATA
    SET SALARY = 65000.00 WHERE ID=3;
COMMIT;

-- 6. NAME이 Ford인 사람을 삭제하고 영구적으로 데이터베이스에 반영하라.
DELETE FROM MY_DATA WHERE NAME='Ford';
COMMIT;
SELECT * FROM MY_DATA;

-- 7. SALARY가 15,000.00 이하인 사람의 급여를 15,000.00으로 변경하라
UPDATE MY_DATA
    SET SALARY = 15000.00 WHERE SALARY <= 15000.00;
SELECT * FROM MY_DATA;

-- 8. 위에서 생성한 테이블을 삭제하라.
DELETE MY_DATA;

-- ★ ★ ★ 제약조건
-- (1) PRIMARY KEY : 테이블의 각 행을 유일한 값으로 식별하기 위한 필드(NULL 불가)
-- (2) FOREIGN KEY : 테이블의 열이 다른 테이블의 열을 참조
-- (3) NOT NULL : NULL을 포함하지 않음
-- (4) UNIQUE : 모든 행이 값이 유일. NULL값은 허용(NULL은 여러개 가능)
-- (5) CHECK (조건) : 해당 조건이 만족 ( NULL값 허용)
-- DEFAULT 기본값 : 기본값 설정(해당 열의 데이터를 입력하지 않으면 원래는 NULL이 들어갈 것을 DEFAULT값으로 입력)
INSERT INTO DEPT01 (DEPTNO, DNAME) VALUES(99,'XX');
SELECT * FROM DEPT01 WHERE DEPTNO=99;


-- DEPT1 테이블 생성
CREATE TABLE DEPT1 (
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME  VARCHAR2(14) NOT NULL UNIQUE,
    LOC    VARCHAR2(13) NOT NULL
);
SELECT * FROM DEPT1;
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='DEPT1';

-- EMP1 테이블 생성
DROP TABLE EMP1;
CREATE TABLE EMP1 (
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    JOB   VARCHAR2(9)  NOT NULL,
    MGR   NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL   NUMBER(7,2) CHECK(SAL>0),
    COMM  NUMBER(7,2),
    DEPTNO NUMBER(2) REFERENCES DEPT1(DEPTNO)
);
DROP TABLE EMP1;
CREATE TABLE EMP1 (
    EMPNO NUMBER(4) ,
    ENAME VARCHAR2(10) NOT NULL,
    JOB   VARCHAR2(9)  NOT NULL,
    MGR   NUMBER(4),
    HIREDATE DATE DEFAULT SYSDATE,
    SAL   NUMBER(7,2) ,
    COMM  NUMBER(7,2),
    DEPTNO NUMBER(2),
    PRIMARY KEY(EMPNO),
    CHECK(SAL>0),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT1(DEPTNO)   
);
SELECT * FROM EMP1;
INSERT INTO EMP1 (EMPNO, ENAME, JOB) VALUES (1000, '홍길동', 'MANAGER');
SELECT * FROM EMP1;
INSERT INTO EMP1 (EMPNO, ENAME, JOB) VALUES (1001, '김길동', 'SALESMAN', 10); -- 에러(FK)
INSERT INTO DEPT1 SELECT * FROM DEPT; -- 10,20,30,40 입력
INSERT INTO DEPT1 VALUES(40, 'IT', 'SEOUL'); -- 에러(PK)
INSERT INTO DEPT1 VALUES(50, 'SALES', 'SEOUL'); -- 에러(UNIQUE)
INSERT INTO DEPT1 (DEPTNO, DNAME) VALUES(50, 'IT'); -- 에러(NOT NULL)
INSERT INTO DEPT1 VALUES(50, 'IT', 'SEOUL');
SELECT * FROM DEPT1;
    
INSERT INTO EMP1 (EMPNO, ENAME, JOB, DEPTNO)
    VALUES(1001, '김길동', 'MANAGER', 60); -- 에러(FK)
INSERT INTO EMP1 (EMPNO, ENAME, JOB, SAL, DEPTNO)
    VALUES(1001, '김길동', 'MANAGER',0, 50); -- 에러(CHECK)
INSERT INTO EMP1 (EMPNO, ENAME, JOB, SAL, DEPTNO)
    VALUES(1001, '김길동', 'MANAGER',2000, 50); -- 에러(CHECK)
SELECT * FROM EMP1;

-- BOOK & BOOKCATEGORY 테이블 생성 및 데이터 입력, 출력
DROP TABLE BOOK;
DROP TABLE BOOKCATEGROY;
DROP TABLE BOOKCATEGORY CASCADE CONSTRAINTS; -- 참조하는 테이블 상관없이(비추)

CREATE TABLE BOOKCATEGORY (
    categoryCODE NUMBER(3) PRIMARY KEY,
    categoryNAME VARCHAR2(50) UNIQUE,
    OFFICE_LOC   VARCHAR2(50) NOT NULL
);
CREATE TABLE BOOK(
    bookNO       VARCHAR2(10) PRIMARY KEY,
    categoryCODE NUMBER(3)    REFERENCES BOOKCATEGORY(categoryCODE),
    bookNAME     VARCHAR2(50) NOT NULL,
    PUBLISHER    VARCHAR2(50),
    PUBYEAR      NUMBER(4)    DEFAULT EXTRACT(YEAR FROM SYSDATE)-- TO_CHAR(SYSDATE, 'YYYY')
);
--
INSERT INTO BOOKCATEGORY VALUES (100, '철학', '3층인문실');
INSERT INTO BOOKCATEGORY VALUES (400, 'IT', '4층과학실');
INSERT INTO BOOK (BOOKNO, categoryCODE, bookNAME, PUBLISHER)
    VALUES ('100A01', 100, '철학자의 삶', '이젠출판');
INSERT INTO BOOK VALUES ('400A01', 400, '이것이 DB다', '다음출판', 2022);
--
SELECT bookNO, bookNAME, PUBLISHER, PUBYEAR, categoryNAME, OFFICE_LOC
    FROM BOOK B, BOOKCATEGORY C
    WHERE B.categoryCODE = C.categoryCODE;

-- ★★★DCL : 계정생성, 권한부여, 권한박탈, 계정삭제 ★★★
-- 계정 생성
CREATE USER scott2 IDENTIFIED BY tiger;
-- 권한 부여(세션권한 == 로그인가능)
GRANT CREATE SESSION TO scott2;
GRANT CREATE TABLE TO scott2;
GRANT ALL ON EMP TO scott2;
GRANT SELECT ON DEPT TO scott2;
-- 권한 박탈(DEPT, EMP)
REVOKE ALL ON EMP FROM scott2;
REVOKE SELECT ON DEPT FROM scott2;
-- 계정 삭제(scott2) -- 접속해제
DROP USER scott2 CASCADE;



























